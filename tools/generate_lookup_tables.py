#!/usr/bin/env python3
"""
Generate C++ lookup tables from RME brush_tables.cpp

This script parses RME's brush_tables.cpp and generates .inc files 
containing the lookup table initialization code for:
- BorderLookupTable.inc (256 entries for ground borders)
- WallLookupTable.inc (16 full + 16 half entries for walls)
- TableLookupTable.inc (256 entries for tables)
- CarpetLookupTable.inc (256 entries for carpets)

Usage:
    python generate_lookup_tables.py

Output:
    Creates .inc files in ImguiMapEditor/Services/Brushes/
"""

import re
from pathlib import Path

# ═══════════════════════════════════════════════════════════════════════════
# RME Constants (from brush_enums.h)
# ═══════════════════════════════════════════════════════════════════════════

# TileAlignment flags (8-bit neighbor bitmask)
TILE_FLAGS = {
    'TILE_NORTHWEST': 1,
    'TILE_NORTH': 2,
    'TILE_NORTHEAST': 4,
    'TILE_WEST': 8,
    'TILE_EAST': 16,
    'TILE_SOUTHWEST': 32,
    'TILE_SOUTH': 64,
    'TILE_SOUTHEAST': 128,
}

# WallTileAlignment flags (4-bit neighbor bitmask)
WALL_FLAGS = {
    'WALLTILE_NORTH': 1,
    'WALLTILE_WEST': 2,
    'WALLTILE_EAST': 4,
    'WALLTILE_SOUTH': 8,
}

# BorderType values (ground/carpet borders)
BORDER_TYPES = {
    'BORDER_NONE': 0,
    'NORTH_HORIZONTAL': 1,
    'EAST_HORIZONTAL': 2,
    'SOUTH_HORIZONTAL': 3,
    'WEST_HORIZONTAL': 4,
    'NORTHWEST_CORNER': 5,
    'NORTHEAST_CORNER': 6,
    'SOUTHWEST_CORNER': 7,
    'SOUTHEAST_CORNER': 8,
    'NORTHWEST_DIAGONAL': 9,
    'NORTHEAST_DIAGONAL': 10,
    'SOUTHEAST_DIAGONAL': 11,
    'SOUTHWEST_DIAGONAL': 12,
}

# WallType values
WALL_TYPES = {
    'WALL_POLE': 0,
    'WALL_SOUTH_END': 1,
    'WALL_EAST_END': 2,
    'WALL_NORTHWEST_DIAGONAL': 3,
    'WALL_WEST_END': 4,
    'WALL_NORTHEAST_DIAGONAL': 5,
    'WALL_HORIZONTAL': 6,
    'WALL_SOUTH_T': 7,
    'WALL_NORTH_END': 8,
    'WALL_VERTICAL': 9,
    'WALL_SOUTHWEST_DIAGONAL': 10,
    'WALL_EAST_T': 11,
    'WALL_SOUTHEAST_DIAGONAL': 12,
    'WALL_WEST_T': 13,
    'WALL_NORTH_T': 14,
    'WALL_INTERSECTION': 15,
}

# TableType values
TABLE_TYPES = {
    'TABLE_NORTH_END': 0,
    'TABLE_SOUTH_END': 1,
    'TABLE_EAST_END': 2,
    'TABLE_WEST_END': 3,
    'TABLE_HORIZONTAL': 4,
    'TABLE_VERTICAL': 5,
    'TABLE_ALONE': 6,
}


def eval_flags(expr: str, flag_map: dict) -> int:
    """Evaluate expression like 'TILE_NORTH | TILE_WEST' to integer."""
    if not expr or expr.strip() == '0':
        return 0
    
    result = 0
    for part in re.split(r'\s*\|\s*', expr):
        part = part.strip()
        if part in flag_map:
            result |= flag_map[part]
        elif part.isdigit():
            result = int(part)
    return result


def parse_packed_value(expr: str, type_map: dict) -> int:
    """Parse packed value like 'NORTH_HORIZONTAL | EAST_HORIZONTAL << 8'."""
    if not expr or expr.strip() == '0':
        return 0
    
    result = 0
    parts = re.split(r'\s*\|\s*', expr)
    
    for part in parts:
        part = part.strip()
        if '<<' in part:
            name_part, shift_part = part.split('<<')
            name = name_part.strip()
            shift = int(shift_part.strip())
            value = type_map.get(name, 0)
            result |= (value << shift)
        else:
            value = type_map.get(part, 0)
            result |= value
    
    return result


def parse_table_entries(content: str, table_pattern: str, flag_map: dict, type_map: dict) -> dict:
    """Parse table entries from brush_tables.cpp"""
    entries = {}
    
    # Handle multi-line assignments like:
    # GroundBrush::border_types[TILE_NORTH] // comment
    #     = NORTH_HORIZONTAL;
    # Use DOTALL to match across lines, and handle the comment + newline + tab pattern
    pattern = rf'{table_pattern}\[([^\]]+)\][^\n]*\n\s*=\s*([^;]+);'
    
    for match in re.finditer(pattern, content):
        index_expr = match.group(1).strip()
        value_expr = match.group(2).strip()
        
        index = eval_flags(index_expr, flag_map)
        value = parse_packed_value(value_expr, type_map)
        entries[index] = value
    
    return entries


def generate_border_table(rme_path: Path) -> str:
    """Generate BorderLookupTable.inc from GroundBrush::border_types"""
    content = rme_path.read_text(encoding='utf-8', errors='ignore')
    entries = parse_table_entries(
        content, 
        r'GroundBrush::border_types',
        TILE_FLAGS,
        BORDER_TYPES
    )
    
    lines = [
        '// AUTO-GENERATED from RME brush_tables.cpp - DO NOT EDIT MANUALLY',
        '// Generated by tools/generate_lookup_tables.py',
        '',
        'void BorderLookupService::initializeTable() {',
        '    table_.fill(0);',
    ]
    
    for idx in range(256):
        value = entries.get(idx, 0)
        if value != 0:
            lines.append(f'    table_[{idx}] = 0x{value:08X}U;')
    
    lines.append('}')
    return '\n'.join(lines)


def generate_wall_table(rme_path: Path) -> str:
    """Generate WallLookupTable.inc from WallBrush::full_border_types and half_border_types"""
    content = rme_path.read_text(encoding='utf-8', errors='ignore')
    
    full_entries = parse_table_entries(
        content,
        r'WallBrush::full_border_types',
        WALL_FLAGS,
        WALL_TYPES
    )
    
    half_entries = parse_table_entries(
        content,
        r'WallBrush::half_border_types',
        WALL_FLAGS,
        WALL_TYPES
    )
    
    lines = [
        '// AUTO-GENERATED from RME brush_tables.cpp - DO NOT EDIT MANUALLY',
        '// Generated by tools/generate_lookup_tables.py',
        '',
        'void WallLookupService::initializeTable() {',
        '    // Full wall connections (16 entries)',
    ]
    
    for idx in range(16):
        value = full_entries.get(idx, 0)
        lines.append(f'    fullTable_[{idx}] = static_cast<WallAlign>({value});')
    
    lines.append('')
    lines.append('    // Half wall connections (16 entries)')
    
    for idx in range(16):
        value = half_entries.get(idx, 0)
        lines.append(f'    halfTable_[{idx}] = static_cast<WallAlign>({value});')
    
    lines.append('}')
    return '\n'.join(lines)


def generate_table_table(rme_path: Path) -> str:
    """Generate TableLookupTable.inc from TableBrush::table_types"""
    content = rme_path.read_text(encoding='utf-8', errors='ignore')
    entries = parse_table_entries(
        content,
        r'TableBrush::table_types',
        TILE_FLAGS,
        TABLE_TYPES
    )
    
    lines = [
        '// AUTO-GENERATED from RME brush_tables.cpp - DO NOT EDIT MANUALLY',
        '// Generated by tools/generate_lookup_tables.py',
        '',
        'void TableLookupService::initializeTable() {',
        '    // Default to TABLE_ALONE for unspecified entries',
        '    table_.fill(static_cast<TableAlign>(6));',
    ]
    
    for idx in range(256):
        value = entries.get(idx, 6)  # Default to TABLE_ALONE
        if idx in entries:
            lines.append(f'    table_[{idx}] = static_cast<TableAlign>({value});')
    
    lines.append('}')
    return '\n'.join(lines)


def generate_carpet_table(rme_path: Path) -> str:
    """Generate CarpetLookupTable.inc - uses same table as borders"""
    # Carpet uses the same 256-entry border table structure
    content = rme_path.read_text(encoding='utf-8', errors='ignore')
    entries = parse_table_entries(
        content,
        r'GroundBrush::border_types',  # Carpet reuses border logic
        TILE_FLAGS,
        BORDER_TYPES
    )
    
    lines = [
        '// AUTO-GENERATED from RME brush_tables.cpp - DO NOT EDIT MANUALLY',
        '// Generated by tools/generate_lookup_tables.py',
        '// Note: Carpet uses same table structure as ground borders',
        '',
        'void CarpetLookupService::initializeTable() {',
        '    table_.fill(0);',
    ]
    
    for idx in range(256):
        value = entries.get(idx, 0)
        if value != 0:
            lines.append(f'    table_[{idx}] = 0x{value:08X}U;')
    
    lines.append('}')
    return '\n'.join(lines)


def main():
    # Find paths
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    rme_path = project_root / 'RME_Readonly' / 'source' / 'brush_tables.cpp'
    output_dir = project_root / 'ImguiMapEditor' / 'Services' / 'Brushes'
    
    if not rme_path.exists():
        print(f"ERROR: RME brush_tables.cpp not found at {rme_path}")
        return 1
    
    output_dir.mkdir(parents=True, exist_ok=True)
    
    print(f"Parsing: {rme_path}")
    
    # Generate border table
    border_content = generate_border_table(rme_path)
    border_path = output_dir / 'BorderLookupTable.inc'
    border_path.write_text(border_content)
    print(f"Generated: {border_path}")
    
    # Generate wall table
    wall_content = generate_wall_table(rme_path)
    wall_path = output_dir / 'WallLookupTable.inc'
    wall_path.write_text(wall_content)
    print(f"Generated: {wall_path}")
    
    # Generate table table
    table_content = generate_table_table(rme_path)
    table_path = output_dir / 'TableLookupTable.inc'
    table_path.write_text(table_content)
    print(f"Generated: {table_path}")
    
    # Generate carpet table
    carpet_content = generate_carpet_table(rme_path)
    carpet_path = output_dir / 'CarpetLookupTable.inc'
    carpet_path.write_text(carpet_content)
    print(f"Generated: {carpet_path}")
    
    print("\nDone! All lookup tables generated successfully.")
    return 0


if __name__ == '__main__':
    exit(main())
